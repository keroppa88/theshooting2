 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/index.html b/index.html
index cf3401396c381c5b4419aebf660191878c8813dd..755d87fc95524716b6a48092bfcab34f2da174f4 100644
--- a/index.html
+++ b/index.html
@@ -207,53 +207,55 @@
       [0,0,0,0,2,0,0,0,0],
       [0,0,0,0,2,0,0,0,0],
       [0,0,0,0,1,0,0,0,0],
       [0,0,0,0,1,0,0,0,0],
       [0,0,0,0,2,0,0,0,0],
       [0,0,0,0,2,0,0,0,0],
       [0,0,0,0,0,0,0,0,0]
     ];
 
     // ===== 状態フラグ =====
     let gameStarted  = false;
     let gameOver     = false;
     let gameCleared  = false;
 
     let clearPhase = 0;
     let clearFrame = 0;
     let clearExplosionX = canvas.width / 2;
     let clearExplosionY = canvas.height / 2;
 
     // 大ボス専用・15重リング爆発
     let finalBigExplosion = null;
     // 爆発終了後の白フラッシュ
     let clearFlashTimer = 0; // >0 の間、白く点滅
 
     const missileScorePoints = [500, 600, 700, 800, 900, 1000];
-    const starScorePoints    = [1000, 1300];
+    const starScorePoints         = [1000];
+    const doubleShotStarPoints    = [1000];
     const missileSpawned = {};
     const starSpawned    = {};
+    const doubleShotStarSpawned = {};
 
     // 入力
     const keys = {};
     document.addEventListener("keydown", e => {
       keys[e.code] = true;
 
       // 最初の入力でBGM解除（後の敵撃破で再生できるように）
       unlockBgm();
 
       // タイトル中：何かのボタンでスタート
       if (!gameStarted && clearPhase === 0 && !gameCleared) {
         startGame();
         return;
       }
 
       // クリア後タイトルに戻る
       if (gameCleared &&
           (e.code === "Space" || e.code === "Enter" || e.code === "KeyR")) {
         backToTitle();
       }
 
       // ゲームオーバーからの再開
       if (gameStarted && !gameCleared && gameOver && e.code === "KeyR") {
         startGame();
       }
@@ -284,53 +286,55 @@
       const shoot    = gp.buttons[0]  && gp.buttons[0].pressed;
       const dpadUp   = gp.buttons[12] && gp.buttons[12].pressed;
       const dpadDown = gp.buttons[13] && gp.buttons[13].pressed;
       const dpadLeft = gp.buttons[14] && gp.buttons[14].pressed;
       const dpadRight= gp.buttons[15] && gp.buttons[15].pressed;
       const start    = gp.buttons[9]  && gp.buttons[9].pressed;
 
       return { lx, ly, shoot, dpadUp, dpadDown, dpadLeft, dpadRight, start, raw: gp };
     }
 
     // ===== オブジェクト =====
     const player = {
       x: canvas.width / 2 - 15,
       y: canvas.height - 80,
       w: 30,
       h: 30,
       speed: 5,
       fireCooldown: 0
     };
 
     const bullets = [];
     const enemies = [];
     const enemyBullets = [];
     const explosions = [];
     const powerStars = [];
+    const doubleShotStars = [];
 
     let powerUpActive = false;
-    let powerUpTimer  = 0;  // フレーム
+    let powerUpTimer  = 0;
+    let doubleShotActive = false;
 
     let enemySpawnTimer = 0;
 
     // 追加敵のスポーン制御
     let trailSpawnTimer = 0;   // 5〜10秒
     let hardTwinSpawnTimer = 0; // score>500 で稼働
     let zigzagSpawnTimer = 0;  // score>900 で稼働
 
     let score = 0;
     let nextBossScore = 300;
     let frameCount = 0;
 
     let finalMode        = false;
     let finalDelayFrames = 0;
     let finalBossSpawned = false;
 
     const stars = [];
     for (let i = 0; i < 80; i++) {
       stars.push({
         x: Math.random() * canvas.width,
         y: Math.random() * canvas.height,
         size: 1 + Math.random() * 2
       });
     }
 
@@ -481,50 +485,60 @@
       const h = 48;
       const speed = 6 * 1.5;
       for (let i = 0; i < count; i++) {
         const x = Math.random() * (canvas.width - w);
         const y = -h;
         enemies.push({
           x, y, w, h, speed,
           isBoss: false,
           isFinalBoss: false,
           isShooter: false,
           isMissile: true
         });
       }
     }
 
     function spawnStar() {
       const size = 20;
       const x = Math.random() * (canvas.width - size);
       const y = -size;
       powerStars.push({
         x, y, size,
         speed: 2
       });
     }
 
+    function spawnDoubleShotStar() {
+      const size = 20;
+      const x = Math.random() * (canvas.width - size);
+      const y = -size;
+      doubleShotStars.push({
+        x, y, size,
+        speed: 2.2
+      });
+    }
+
     function createBossAt(x) {
       const baseW = 30;
       const baseH = 30;
       const w = baseW * 9;
       const h = baseH * 9;
       const y = -h;
       const speed = 2;
       enemies.push({
         x, y, w, h, speed,
         isBoss: true,
         isFinalBoss: false,
         isShooter: false,
         isMissile: false,
         hp: 20,
         shotTimer: 180
       });
     }
 
     function spawnBoss() {
       const baseW = 30;
       const w = baseW * 9;
       const x = (canvas.width - w) / 2;
       createBossAt(x);
     }
 
@@ -584,50 +598,56 @@
         }
         nextBossScore += 300;
       }
     }
 
     function tryStartFinalMode() {
       if (!finalMode && score > 1800) {
         finalMode = true;
         finalDelayFrames = 60 * 10; // 10秒敵なし
       }
     }
 
     function handleScoreEvents() {
       for (const p of missileScorePoints) {
         if (!missileSpawned[p] && score >= p) {
           spawnMissilePair();
           missileSpawned[p] = true;
         }
       }
       for (const p of starScorePoints) {
         if (!starSpawned[p] && score >= p) {
           spawnStar();
           starSpawned[p] = true;
         }
       }
+      for (const p of doubleShotStarPoints) {
+        if (!doubleShotStarSpawned[p] && score > p) {
+          spawnDoubleShotStar();
+          doubleShotStarSpawned[p] = true;
+        }
+      }
     }
 
     // ===== 大ボス専用 15重リング爆発（全面改訂版） =====
     function createFinalBigExplosion(x, y) {
       // 最大半径：従来より 1.5 倍（画面の短い辺の約 0.6）
       const maxRadius = Math.min(canvas.width, canvas.height) * 0.6;
       const maxLife   = 120; // 約2秒
 
       const baseColors = [
         "#ffffff", "#ffe066", "#ff9933", "#ff5555", "#ff66ff",
         "#66ccff", "#66ff66", "#ffff66", "#ff99cc", "#99ff99",
         "#99ccff", "#ffcc66", "#ff6666", "#ccccff", "#ffffff"
       ];
 
       const rings = [];
       for (let i = 0; i < 15; i++) {
         rings.push({
           color: baseColors[i % baseColors.length],
           delay: i * 0.03,        // 後ろのリングほど少し遅れて広がる
           width: 3 + i * 0.3      // 外側ほど太く
         });
       }
 
       finalBigExplosion = {
         x,
@@ -701,73 +721,78 @@
         ctx.beginPath();
         ctx.arc(fw.x, fw.y, radius, 0, Math.PI * 2);
         ctx.stroke();
       }
 
       ctx.restore();
     }
 
     function startClearSequence(cx, cy) {
       clearPhase = 1;
       clearFrame = 0;
       explosions.length = 0;
       bullets.length = 0;
       enemyBullets.length = 0;
       enemies.length = 0;
 
       clearExplosionX = (cx !== undefined) ? cx : canvas.width / 2;
       clearExplosionY = (cy !== undefined) ? cy : canvas.height / 2;
 
       // 大ボス撃破地点で15重リング爆発
       createFinalBigExplosion(clearExplosionX, clearExplosionY);
       clearFlashTimer = 0; // フラッシュ用タイマー初期化
     }
 
     // ===== 自機弾 =====
-    function spawnPlayerBullet(angleDeg) {
+    function spawnPlayerBullet(angleDeg, offsetX = 0) {
       const speed = 8;
       const rad = angleDeg * Math.PI / 180;
       const vx = Math.sin(rad) * speed;
       const vy = -Math.cos(rad) * speed;
 
       bullets.push({
-        x: player.x + player.w / 2 - 3,
+        x: player.x + player.w / 2 - 3 + offsetX,
         y: player.y,
         w: 6,
         h: 12,
         vx,
         vy
       });
     }
 
     function firePlayerShots() {
-      if (powerUpActive) {
-        spawnPlayerBullet(-20);
-        spawnPlayerBullet(0);
-        spawnPlayerBullet(20);
+      const baseAngles = powerUpActive ? [-20, 0, 20] : [0];
+      if (doubleShotActive) {
+        const offset = 8;
+        for (const ang of baseAngles) {
+          spawnPlayerBullet(ang, -offset);
+          spawnPlayerBullet(ang,  offset);
+        }
       } else {
-        spawnPlayerBullet(0);
+        for (const ang of baseAngles) {
+          spawnPlayerBullet(ang);
+        }
       }
       playSound(shootSound);
     }
 
     // ===== 敵弾 =====
     function fireEnemyBulletsFromEnemy(enemy) {
       const speed = 5;
       const angle = Math.PI / 6;
 
       const cx = enemy.x + enemy.w / 2 - 2;
       const cy = enemy.y + enemy.h / 2;
 
       if (enemy.shotPattern === "double") {
         enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx: 0, vy: speed });
 
         const vx = Math.sin(angle) * speed * enemy.diagDir;
         const vy = Math.cos(angle) * speed;
         enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx, vy });
       } else {
         const vx = Math.sin(angle) * speed * enemy.diagDir;
         const vy = Math.cos(angle) * speed;
         enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx, vy });
       }
     }
 
@@ -806,50 +831,54 @@
         if (Math.abs(pad.ly) > dead) player.y += pad.ly * player.speed;
         if (pad.dpadLeft)  player.x -= player.speed;
         if (pad.dpadRight) player.x += player.speed;
         if (pad.dpadUp)    player.y -= player.speed;
         if (pad.dpadDown)  player.y += player.speed;
       }
 
       player.x = Math.max(0, Math.min(canvas.width  - player.w, player.x));
       player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));
 
       if (player.fireCooldown > 0) player.fireCooldown--;
 
       const wantShootKeyboard = keys["Space"] || keys["KeyJ"];
       const pad2 = readGamepad();
       const wantShootPad = pad2 && pad2.shoot;
 
       if ((wantShootKeyboard || wantShootPad) && player.fireCooldown === 0) {
         firePlayerShots();
         player.fireCooldown = 8;
       }
 
       if (powerUpActive) {
         powerUpTimer--;
         if (powerUpTimer <= 0) powerUpActive = false;
       }
+
+      if (doubleShotActive && score >= 1800) {
+        doubleShotActive = false;
+      }
     }
 
     function updateBullets() {
       for (let i = bullets.length - 1; i >= 0; i--) {
         const b = bullets[i];
         b.x += b.vx;
         b.y += b.vy;
         if (b.y + b.h < 0 || b.y > canvas.height ||
             b.x + b.w < 0 || b.x > canvas.width) {
           bullets.splice(i, 1);
         }
       }
     }
 
     function updateEnemyBullets() {
       for (let i = enemyBullets.length - 1; i >= 0; i--) {
         const b = enemyBullets[i];
         b.x += b.vx;
         b.y += b.vy;
 
         if (b.y > canvas.height || b.x + b.w < 0 || b.x > canvas.width) {
           enemyBullets.splice(i, 1);
           continue;
         }
         if (rectHit({x: player.x, y: player.y, w: player.w, h: player.h}, b)) {
@@ -1038,50 +1067,67 @@
           gameOver = true;
           playSound(playerExplodeSound);
           createExplosion(player.x + player.w/2, player.y + player.h/2, false);
         }
       }
     }
 
     function updateStarsPower() {
       for (let i = powerStars.length - 1; i >= 0; i--) {
         const s = powerStars[i];
         s.y += s.speed;
         if (s.y > canvas.height) {
           powerStars.splice(i, 1);
           continue;
         }
         const rect = { x: s.x, y: s.y, w: s.size, h: s.size };
         if (rectHit(player, rect)) {
           powerUpActive = true;
           powerUpTimer  = 60 * 5;  // 5秒
           powerStars.splice(i, 1);
           playSound(starSound);
         }
       }
     }
 
+    function updateDoubleShotStars() {
+      for (let i = doubleShotStars.length - 1; i >= 0; i--) {
+        const s = doubleShotStars[i];
+        s.y += s.speed;
+        if (s.y > canvas.height) {
+          doubleShotStars.splice(i, 1);
+          continue;
+        }
+        const rect = { x: s.x, y: s.y, w: s.size, h: s.size };
+        if (rectHit(player, rect)) {
+          doubleShotActive = true;
+          doubleShotStars.splice(i, 1);
+          playSound(starSound);
+        }
+      }
+    }
+
     function handleCollisions() {
       for (let i = enemies.length - 1; i >= 0; i--) {
         const e = enemies[i];
         for (let j = bullets.length - 1; j >= 0; j--) {
           const b = bullets[j];
           if (rectHit(e, b)) {
             const exX = e.x + e.w / 2;
             const exY = e.y + e.h / 2;
 
             bullets.splice(j, 1);
 
             // 最初の敵撃破でBGM開始（解除済みなら）
             startBgmIfReady();
 
             if (e.isFinalBoss) {
               e.hp--;
               if (e.hp <= 0) {
                 playSound(playerExplodeSound);
                 startClearSequence(exX, exY); // ここで15重リング演出へ
               }
               break;
             }
 
             // 頑丈な敵（横2体）：HP=35
             if (e.type === "hard_twin") {
@@ -1456,75 +1502,105 @@
               if (v === 0) continue;
               ctx.fillStyle = "#9aa0a6";
               ctx.fillRect(xx * cellW, yy * cellH, cellW, cellH);
             }
           }
 
         } else {
           ctx.translate(e.w / 2, e.h / 2);
           ctx.fillStyle = e.color ? e.color : (e.isShooter ? "#ff66aa" : "#f33");
           ctx.fillRect(-4, -12, 8, 24);
           ctx.fillRect(-14, -3, 28, 6);
           ctx.fillRect(-5, 7, 10, 4);
 
           ctx.fillStyle = "#faa";
           ctx.fillRect(-3, -9, 6, 5);
         }
 
         ctx.restore();
       }
     }
 
     function drawUI() {
       ctx.fillStyle = "#fff";
       ctx.font = "18px sans-serif";
       ctx.fillText("SCORE: " + score, 10, 24);
+      let uiY = 48;
       if (powerUpActive) {
         ctx.font = "14px sans-serif";
-        ctx.fillText("TRIPLE SHOT!", 10, 48);
+        ctx.fillText("TRIPLE SHOT!", 10, uiY);
+        uiY += 20;
+      }
+      if (doubleShotActive && score < 1800) {
+        ctx.font = "14px sans-serif";
+        ctx.fillText("DOUBLE SHOT ACTIVE", 10, uiY);
       }
     }
 
     function drawGameOver() {
       ctx.fillStyle = "rgba(0,0,0,0.6)";
       ctx.fillRect(0, 0, canvas.width, canvas.height);
       ctx.fillStyle = "#fff";
       ctx.font = "32px sans-serif";
       ctx.textAlign = "center";
       ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 10);
       ctx.font = "20px sans-serif";
       ctx.fillText("Rキーでリスタート", canvas.width / 2, canvas.height / 2 + 30);
       ctx.textAlign = "left";
     }
 
     function drawStarsPower() {
       for (const s of powerStars) {
         const cx = s.x + s.size / 2;
         const cy = s.y + s.size / 2;
         const r  = s.size / 2;
 
-        ctx.fillStyle = "#ffff66";
+        const blinkOn = Math.floor(frameCount / 10) % 2 === 0;
+        ctx.fillStyle = blinkOn ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.35)";
+        ctx.beginPath();
+        for (let i = 0; i < 5; i++) {
+          const ang  = (Math.PI * 2 / 5) * i - Math.PI / 2;
+          const ang2 = ang + Math.PI / 5;
+          const r1 = r;
+          const r2 = r * 0.4;
+          if (i === 0) ctx.moveTo(cx + Math.cos(ang) * r1, cy + Math.sin(ang) * r1);
+          ctx.lineTo(cx + Math.cos(ang) * r1,  cy + Math.sin(ang) * r1);
+          ctx.lineTo(cx + Math.cos(ang2) * r2, cy + Math.sin(ang2) * r2);
+        }
+        ctx.closePath();
+        ctx.fill();
+      }
+    }
+
+    function drawDoubleShotStars() {
+      for (const s of doubleShotStars) {
+        const cx = s.x + s.size / 2;
+        const cy = s.y + s.size / 2;
+        const r  = s.size / 2;
+
+        const blinkOn = Math.floor(frameCount / 8) % 2 === 0;
+        ctx.fillStyle = blinkOn ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.35)";
         ctx.beginPath();
         for (let i = 0; i < 5; i++) {
           const ang  = (Math.PI * 2 / 5) * i - Math.PI / 2;
           const ang2 = ang + Math.PI / 5;
           const r1 = r;
           const r2 = r * 0.4;
           if (i === 0) ctx.moveTo(cx + Math.cos(ang) * r1, cy + Math.sin(ang) * r1);
           ctx.lineTo(cx + Math.cos(ang) * r1,  cy + Math.sin(ang) * r1);
           ctx.lineTo(cx + Math.cos(ang2) * r2, cy + Math.sin(ang2) * r2);
         }
         ctx.closePath();
         ctx.fill();
       }
     }
 
     // ===== クリア演出 =====
     function drawClearScreen() {
       if (endingImageLoaded) {
         ctx.drawImage(endingImage, 0, 0, canvas.width, canvas.height);
       } else {
         ctx.fillStyle = "#000";
         ctx.fillRect(0, 0, canvas.width, canvas.height);
         ctx.fillStyle = "#ffffff";
         ctx.textAlign = "center";
         ctx.font = "26px monospace";
@@ -1587,94 +1663,99 @@ function drawClearExplosionPhase() {
       if (player.y < limitY) player.y = limitY;
 
       if (clearFrame >= 60 * 5) {
         clearPhase = 3;
         clearFrame = 0;
         gameCleared = true;
       }
     }
 
     function drawCruisePhase() {
       ctx.fillStyle = "#000";
       ctx.fillRect(0, 0, canvas.width, canvas.height);
 
       ctx.fillStyle = "#ffffff";
       for (const s of stars) {
         ctx.fillRect(s.x, s.y, s.size, s.size);
       }
 
       drawPlayer();
     }
 
     // ===== スコア関連フラグリセット =====
     function resetScoreFlags() {
       for (const k in missileSpawned) delete missileSpawned[k];
       for (const k in starSpawned) delete starSpawned[k];
+      for (const k in doubleShotStarSpawned) delete doubleShotStarSpawned[k];
     }
 
     function startGame() {
       bullets.length = 0;
       enemies.length = 0;
       enemyBullets.length = 0;
       explosions.length = 0;
       powerStars.length = 0;
+      doubleShotStars.length = 0;
       resetScoreFlags();
       powerUpActive = false;
       powerUpTimer  = 0;
+      doubleShotActive = false;
 
       score = 0;
       nextBossScore = 300;
       enemySpawnTimer = 30;
       trailSpawnTimer = randInt(60 * 5, 60 * 10);
       hardTwinSpawnTimer = randInt(60 * 6, 60 * 12);
       zigzagSpawnTimer = randInt(60 * 6, 60 * 12);
       player.x = canvas.width / 2 - 15;
       player.y = canvas.height - 80;
       player.fireCooldown = 0;
       gameOver = false;
       gameStarted = true;
       gameCleared = false;
 
       finalMode = false;
       finalDelayFrames = 0;
       finalBossSpawned = false;
 
       clearPhase = 0;
       clearFrame = 0;
       finalBigExplosion = null;
       clearFlashTimer = 0;
     }
 
     function backToTitle() {
       bullets.length = 0;
       enemies.length = 0;
       enemyBullets.length = 0;
       explosions.length = 0;
       powerStars.length = 0;
+      doubleShotStars.length = 0;
       resetScoreFlags();
       powerUpActive = false;
       powerUpTimer  = 0;
+      doubleShotActive = false;
 
       score = 0;
       nextBossScore = 300;
       enemySpawnTimer = 30;
       trailSpawnTimer = randInt(60 * 5, 60 * 10);
       hardTwinSpawnTimer = randInt(60 * 6, 60 * 12);
       zigzagSpawnTimer = randInt(60 * 6, 60 * 12);
       player.fireCooldown = 0;
 
       finalMode = false;
       finalDelayFrames = 0;
       finalBossSpawned = false;
 
       clearPhase = 0;
       clearFrame = 0;
       finalBigExplosion = null;
       clearFlashTimer = 0;
 
       gameStarted = false;
       gameOver = false;
       gameCleared = false;
     }
 
     // ===== メインループ =====
     enemySpawnTimer = 30;
@@ -1693,57 +1774,59 @@ function drawClearExplosionPhase() {
       } else if (clearPhase === 2) {
         updateCruisePhase();
         drawCruisePhase();
       } else if (clearPhase === 3) {
         drawClearScreen();
       } else if (!gameStarted) {
         // タイトル画面
         drawTitleScreen();
 
         // パッドでも最初のボタンでスタート＆BGM解除
         if (pad0 && pad0.buttons) {
           const anyPressed = pad0.buttons.some(b => b.pressed);
           if (anyPressed) {
             unlockBgm();
             startGame();
           }
         }
       } else {
         // ゲーム進行
         if (!gameOver) {
           updatePlayer();
           updateBullets();
           updateEnemyBullets();
           updateEnemies();
           updateStarsPower();
+          updateDoubleShotStars();
           handleCollisions();
           updateExplosions();
 
           drawPlayer();
           drawBullets();
           drawEnemyBullets();
           drawEnemyTrails();
           drawEnemies();
           drawExplosions();
           drawStarsPower();
+          drawDoubleShotStars();
           drawUI();
         } else {
           updateExplosions();
           drawPlayer();
           drawBullets();
           drawEnemyBullets();
           drawEnemyTrails();
           drawEnemies();
           drawExplosions();
           drawUI();
           drawGameOver();
         }
       }
 
       requestAnimationFrame(loop);
     }
 
     loop();
   </script>
 </body>
 </html>
 
 
EOF
)
