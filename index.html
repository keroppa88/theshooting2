<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>The ShootingⅡ</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: sans-serif;
    }
    canvas {
      background: #111;
      border: 2px solid #555;
    }
  </style>
</head>
<body>
  <canvas id="game" width="480" height="640"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // クリック/タップでも開始できるようにする（フォーカス問題対策）
    canvas.tabIndex = 0;
    canvas.style.outline = "none";
    canvas.focus();
    canvas.addEventListener("pointerdown", () => {
      unlockBgm();
      if (!gameStarted && clearPhase === 0 && !gameCleared) startGame();
    });


    // ===== 効果音 =====
    const shootSound         = new Audio("Game/shoot.mp3");
    const enemyExplodeSound  = new Audio("Game/enemy_explode.mp3");
    const playerExplodeSound = new Audio("Game/player_explode.mp3");
    const starSound          = new Audio("Game/star.mp3");

    shootSound.volume         = 0.2;
    enemyExplodeSound.volume  = 0.2;
    playerExplodeSound.volume = 0.2;
    starSound.volume          = 0.3;

    function playSound(sound) {
      const s = sound.cloneNode();
      s.volume = sound.volume;
      s.play();
    }

    // ===== BGM（最初の敵を倒したときに鳴らす） =====
    const bgm = new Audio("Game/music.mp3");
    bgm.loop = true;
    bgm.volume = 0.2;
    let bgmUnlocked = false;  // ユーザー操作で一度だけ解除
    let bgmPlaying  = false;  // 実際に再生を開始したか

    function unlockBgm() {
      if (bgmUnlocked) return;
      const prevVol = bgm.volume;
      bgm.volume = 0;
      const p = bgm.play();
      if (p && p.then) {
        p.then(() => {
          bgm.pause();
          bgm.currentTime = 0;
          bgm.volume = prevVol;
          bgmUnlocked = true;
        }).catch(() => {
          bgm.volume = prevVol;
        });
      } else {
        bgmUnlocked = true;
        bgm.volume = prevVol;
      }
    }

    function startBgmIfReady() {
      if (!bgmUnlocked || bgmPlaying) return;
      bgm.currentTime = 0;
      const p = bgm.play();
      if (p && p.then) {
        p.then(() => {
          bgmPlaying = true;
        }).catch(() => {});
      } else {
        bgmPlaying = true;
      }
    }

    // ===== スクロール背景画像 =====

    const backgroundScrollSpeed = 0.9;

    function createBackgroundScroll(src, triggerScore) {
      const image = new Image();
      const state = {
        image,
        loaded: false,
        triggered: false,
        pending: false,
        active: false,
        y: -canvas.height,
        triggerScore,
      };

      image.onload = () => {
        state.loaded = true;
        if (state.pending) {
          startBackgroundScroll(state);
        }
      };

      image.src = src;
      return state;
    }

const backgroundScrolls = [
  createBackgroundScroll("Game/back2.png", 1650),

      // back2だけ2コマ特例（createBackgroundScrollを使わない）
      (() => {
        const bg = {
          frames: [new Image(), new Image()],
          loadedCount: 0,
          loaded: false,
          triggered: false,
          pending: false,
          active: false,
          y: -canvas.height,
          triggerScore: 1050,
          frameInterval: 12,
        };

        const onload = () => {
          bg.loadedCount++;
          if (bg.loadedCount >= 2) {
            bg.loaded = true;
            if (bg.pending) startBackgroundScroll(bg);
          }
        };

        // ★先にonloadを付ける（ここが重要）
        bg.frames[0].onload = onload;
        bg.frames[1].onload = onload;

        bg.frames[0].src = "Game/back2_0.png";
        bg.frames[1].src = "Game/back2_1.png";

        return bg;
      })(),
    ];
    // ===== エンディング画像 =====
    const endingImage = new Image();
    endingImage.src = "Game/last.jpg";
    let endingImageLoaded = false;
    endingImage.onload = () => { endingImageLoaded = true; };


 // ===== 最終ボス画像 =====
    const finalBossImage = new Image();
    finalBossImage.src = "Game/boss.png";
    let finalBossImageLoaded = false;
    finalBossImage.onload = () => {
      finalBossImageLoaded = true;

      // 画像ロード後に既存の最終ボスがいれば、実寸に合わせて衝突サイズを更新する
      const existingFinalBoss = enemies.find(e => e.isFinalBoss);
      if (existingFinalBoss) {
        resizeFinalBossEntity(existingFinalBoss);
      }
    };

    // ===== 中ボス（飛行機）ドットマップ =====
    // 0: 空白, 1: 暗い水色, 2: 水色, 3: 紺色, 4: グレー, 5: 濃いグレー, 6: 赤, 7: オレンジ
    const midBossMap = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 3, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 3, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 4, 0, 4, 0, 4, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 4, 0, 4, 0, 4, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 6, 0, 6, 0, 6, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 6, 0, 6, 0, 6, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 4, 0, 4, 0, 4, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 4, 0, 4, 0, 4, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0],
      [0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0],
      [0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0],
      [0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 0, 0],
      [0, 0, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 7, 0, 0],
      [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
      [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 4, 0, 4, 0, 4, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 4, 0, 4, 0, 4, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 6, 0, 6, 0, 6, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 6, 0, 6, 0, 6, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 6, 0, 6, 0, 6, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 6, 0, 6, 0, 6, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ];

    // ===== 自機ドットマップ =====
    // 0: 透明
    // 1: 明るい緑, 2: 濃い緑, 3: 赤, 4: 水色, 5: 濃いグレー, 6: 暗いオレンジ
    const playerMap = [
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,4,4,4,6,4,4,4,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,4,1,0,0,0,0,0,0,0,0,0,0],
      [0,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,0],
      [0,1,1,1,3,1,1,1,1,1,1,4,1,1,1,1,1,1,3,1,1,1,0],
      [0,0,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,4,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,1,1,1,1,2,1,1,1,1,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,1,1,1,1,2,1,1,1,1,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    // ===== ミサイルのドットマップ =====
    // 0: 空白, 1: 白, 2: 赤
    const missileMap = [
      [0,0,0,0,0,0,0,0,0],
      [0,0,0,1,1,1,0,0,0],
      [0,0,0,0,1,0,0,0,0],
      [0,0,0,0,1,0,0,0,0],
      [0,0,0,0,1,0,0,0,0],
      [0,0,0,1,2,1,0,0,0],
      [0,0,0,0,2,0,0,0,0],
      [0,0,0,0,2,0,0,0,0],
      [0,0,0,0,1,0,0,0,0],
      [0,0,0,0,1,0,0,0,0],
      [0,0,0,0,2,0,0,0,0],
      [0,0,0,0,2,0,0,0,0],
      [0,0,0,0,0,0,0,0,0]
    ];

    // ===== 状態フラグ =====
    let gameStarted  = false;
    let gameOver     = false;
    let gameCleared  = false;

    let clearPhase = 0;
    let clearFrame = 0;
    let clearExplosionX = canvas.width / 2;
    let clearExplosionY = canvas.height / 2;

    // 直近のエラーを保持（デバッグ用途。未宣言のまま使われないよう初期化）
    let lastError = null;


    // 大ボス専用・15重リング爆発
    let finalBigExplosion = null;
    // 爆発終了後の白フラッシュ
    let clearFlashTimer = 0; // >0 の間、白く点滅

    function startBackgroundScroll(bg) {
      bg.y = -canvas.height;
      bg.active = true;
      bg.pending = false;
    }

    function resetBackgroundScrolls() {
      for (const bg of backgroundScrolls) {
        bg.triggered = false;
        bg.pending = false;
        bg.active = false;
        bg.y = -canvas.height;
      }
    }

    const missileScorePoints = [500, 600, 700, 800, 900, 1000];
    const starScorePoints         = [1000,1300];
    const doubleShotStarPoints    = [1500];
    const doubleShotEndScore      = 1800;
    const missileSpawned = {};
    const starSpawned    = {};
    const doubleShotStarSpawned = {};
    
    // 入力
    const keys = {};
    document.addEventListener("keydown", e => {
      keys[e.code] = true;

      // 最初の入力でBGM解除（後の敵撃破で再生できるように）
      unlockBgm();

      // タイトル中：何かのボタンでスタート
      if (!gameStarted && clearPhase === 0 && !gameCleared) {
        startGame();
        return;
      }

      // クリア後タイトルに戻る
      if (gameCleared &&
          (e.code === "Space" || e.code === "Enter" || e.code === "KeyR")) {
        backToTitle();
      }

      // ゲームオーバーからの再開
      if (gameStarted && !gameCleared && gameOver && e.code === "KeyR") {
        startGame();
      }
    });

    document.addEventListener("keyup", e => {
      keys[e.code] = false;
    });

    // ゲームパッド
    let activeGamepadIndex = null;
    window.addEventListener("gamepadconnected", e => {
      activeGamepadIndex = e.gamepad.index;
    });
    window.addEventListener("gamepaddisconnected", e => {
      if (activeGamepadIndex === e.gamepad.index) activeGamepadIndex = null;
    });

    const restartGamepadButtons = [0, 1, 2, 3, 9]; // ABXY + START
    let prevGamepadButtons = [];

    function isGamepadRestartJustPressed(gp) {
      if (!gp || !gp.buttons) {
        prevGamepadButtons = [];
        return false;
      }

      const nextButtons = gp.buttons.map(b => !!(b && b.pressed));
      const pressed = restartGamepadButtons.some(idx => nextButtons[idx] && !prevGamepadButtons[idx]);

      prevGamepadButtons = nextButtons;
      return pressed;
    }

    function readGamepad() {
      if (!navigator.getGamepads) return null;
      const pads = navigator.getGamepads();
      let gp = (activeGamepadIndex != null) ? pads[activeGamepadIndex] : pads[0];
      if (!gp) return null;

      const lx = gp.axes[0] || 0;
      const ly = gp.axes[1] || 0;

      const shoot    = gp.buttons[0]  && gp.buttons[0].pressed;
      const dpadUp   = gp.buttons[12] && gp.buttons[12].pressed;
      const dpadDown = gp.buttons[13] && gp.buttons[13].pressed;
      const dpadLeft = gp.buttons[14] && gp.buttons[14].pressed;
      const dpadRight= gp.buttons[15] && gp.buttons[15].pressed;
      const start    = gp.buttons[9]  && gp.buttons[9].pressed;

      return { lx, ly, shoot, dpadUp, dpadDown, dpadLeft, dpadRight, start, raw: gp };
    }

    // ===== オブジェクト =====
    const player = {
      x: canvas.width / 2 - 15,
      y: canvas.height - 80,
      w: 30,
      h: 30,
      speed: 5,
      fireCooldown: 0
    };

    const bullets = [];
    const enemies = [];
    const enemyBullets = [];
    const explosions = [];
    const powerStars = [];
    const doubleShotStars = [];
    
    let powerUpActive = false; 
    let powerUpTimer  = 0;
    let doubleShotActive = false;

    let enemySpawnTimer = 0;

    // 追加敵のスポーン制御
    let trailSpawnTimer = 0;   // 5〜10秒
    let hardTwinSpawnTimer = 0; // score>500 で稼働
    let zigzagSpawnTimer = 0;  // score>900 で稼働

    let score = 0;
    let nextBossScore = 300;
    let frameCount = 0;

    let finalMode        = false;
    let finalDelayFrames = 0;
    let finalBossSpawned = false;

    const stars = [];
    for (let i = 0; i < 80; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: 1 + Math.random() * 2
      });
    }

    function getShooterRatio(score) {
      if (finalMode) return 0;
      if (score > 1300) return 0.5;
      if (score > 1000) return 1/3;
      if (score > 500)  return 0.25;
      return 0;
    }

    function spawnEnemy() {
      const w = 30;
      const h = 30;
      const x = Math.random() * (canvas.width - w);
      const y = -h;
      const speed = 2 + Math.random() * 2;

      const shooterRatio = getShooterRatio(score);
      const canShoot = (shooterRatio > 0) && (Math.random() < shooterRatio);
      const isDoublePattern = (score > 1300);

      const e = {
        x, y, w, h, speed,
        isBoss: false,
        isFinalBoss: false,
        isShooter: canShoot,
        isMissile: false,
        shotPattern: isDoublePattern ? "double" : "single",
        diagDir: (Math.random() < 0.5 ? -1 : 1),
        shotTimer: 0,
        shotsLeft: 0,
        // trail (visual only)
        trail: [],
        trailColor: TRAIL_COLORS[(Math.random()*TRAIL_COLORS.length)|0]
      };

      if (canShoot) {
        fireEnemyBulletsFromEnemy(e);
        e.shotsLeft = 1;
        e.shotTimer = 120; // 2秒後
      }

      enemies.push(e);
    }

    // ===== 追加通常敵（色違い） =====
    const TRAIL_COLORS = [
      "rgba(255,255,255,0.85)", // white
      "rgba(255,0,0,0.85)",     // red
      "rgba(255,105,180,0.85)", // pink
      "rgba(120,200,255,0.85)", // light blue
      "rgba(0,120,255,0.85)",   // blue
      "rgba(0,255,200,0.85)",   // teal
      "rgba(150,255,80,0.85)",  // yellow-green
      "rgba(190,120,255,0.85)", // bright purple
      "rgba(255,255,0,0.85)",   // yellow
      "rgba(255,165,0,0.85)"    // orange
    ];

    function randInt(min, max) {
      return (min + Math.random() * (max - min + 1)) | 0;
    }

    // ①軌跡を描く敵（2秒に1回・直進弾）
    function spawnTrailEnemy() {
      const w = 30;
      const h = 30;
      const x = Math.random() * (canvas.width - w);
      const y = -h;

      enemies.push({
        type: "trail_enemy",
        x, y, w, h,
        speed: 2,
        isBoss: false,
        isFinalBoss: false,
        isShooter: false,
        isMissile: false,
        color: "#ffdd44",
        trail: [],
        trailColor: TRAIL_COLORS[randInt(0, TRAIL_COLORS.length - 1)],
        shotTimer: 120
      });
    }

    // ②ジグザグ敵（3秒に1回・斜め±30度に2発）
    function spawnZigzagEnemy() {
      const w = 30;
      const h = 30;
      const x = Math.random() * (canvas.width - w);
      const y = -h;

      enemies.push({
        type: "zigzag_enemy",
        x, y, w, h,
        speed: 1.8,
        baseX: x,
        zigPhase: Math.random() * Math.PI * 2,
        zigAmp: 70,
        isBoss: false,
        isFinalBoss: false,
        isShooter: false,
        isMissile: false,
        color: "#66ccff",
        shotTimer: 180
      });
    }

    // ③横に2体ぶんの頑丈すぎる敵（HP=35、攻撃なし）
    const hardTwinMap = [
      [0,0,0,0,0,0,0,0],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1],
      [1,1,1,1,1,1,1,1]
    ];

    function spawnHardTwin() {
      const cols = hardTwinMap[0].length;
      const rows = hardTwinMap.length;

      const w = 120;
      const h = 60; // 横長で固定
      const x = Math.random() * (canvas.width - w);
      const y = -h;

      enemies.push({
        type: "hard_twin",
        x, y, w, h,
        speed: 1.0,
        isBoss: false,
        isFinalBoss: false,
        isShooter: false,
        isMissile: false,
        hp: 35
      });
    }

    function spawnMissilePair() {
      const count = 2;
      const w = 12;
      const h = 48;
      const speed = 6 * 1.5;
      for (let i = 0; i < count; i++) {
        const x = Math.random() * (canvas.width - w);
        const y = -h;
        enemies.push({
          x, y, w, h, speed,
          isBoss: false,
          isFinalBoss: false,
          isShooter: false,
          isMissile: true
        });
      }
    }

    function spawnStar() {
      const size = 20;
      const x = Math.random() * (canvas.width - size);
      const y = -size;
      powerStars.push({
        x, y, size,
        speed: 2
      });
    }

    function spawnDoubleShotStar() {
      const size = 20;
      const x = Math.random() * (canvas.width - size);
      const y = -size;
      doubleShotStars.push({
        x, y, size,
        speed: 2.2
      });
    }

    function createBossAt(x) {
      const baseW = 30;
      const baseH = 30;
      const w = baseW * 9;
      const h = baseH * 9;
      const y = -h;
      const speed = 2;
      enemies.push({
        x, y, w, h, speed,
        isBoss: true,
        isFinalBoss: false,
        isShooter: false,
        isMissile: false,
        hp: 20,
        shotTimer: 180
      });
    }

    function spawnBoss() {
      const baseW = 30;
      const w = baseW * 9;
      const x = (canvas.width - w) / 2;
      createBossAt(x);
    }

    function spawnBossPair() {
      const baseW = 30;
      const w = baseW * 9;
      const leftX  = canvas.width * 0.25 - w / 2;
      const rightX = canvas.width * 0.75 - w / 2;
      createBossAt(leftX);
      createBossAt(rightX);
    }
    function getFinalBossSize() {
      const desiredH = canvas.height / 3;
      const aspect = (finalBossImageLoaded && finalBossImage.naturalHeight > 0)
        ? finalBossImage.naturalWidth / finalBossImage.naturalHeight
        : 1;

      return { w: desiredH * aspect, h: desiredH };
    }

    function resizeFinalBossEntity(boss) {
      const { w, h } = getFinalBossSize();
      const centerX = boss.x + boss.w / 2;

      boss.w = w;
      boss.h = h;
      boss.x = Math.max(0, Math.min(canvas.width - w, centerX - w / 2));
    }

    function spawnFinalBoss() {
      const { w, h } = getFinalBossSize();


      const x = (canvas.width - w) / 2;
      const y = canvas.height * 0.05; // 画面上部に表示
      const speed = 2;

      enemies.push({
        x, y, w, h, speed,
        isBoss: true,
        isFinalBoss: true,
        isShooter: false,
        isMissile: false,
        hp: 130,
        moveDir: 1,
        shotTimer: 120
      });
    }

    function checkBossSpawn() {
      if (finalMode) return;
      while (score >= nextBossScore) {
        if (nextBossScore === 1500) {
          spawnBossPair();
        } else {
          spawnBoss();
        }
        nextBossScore += 300;
      }
    }

    function tryStartFinalMode() {
      if (!finalMode && score > 1800) {
        finalMode = true;
        finalDelayFrames = 60 * 10; // 10秒敵なし
      }
    }

    function handleScoreEvents() {
      for (const p of missileScorePoints) {
        if (!missileSpawned[p] && score >= p) {
          spawnMissilePair();
          missileSpawned[p] = true;
        }
      }
      for (const p of starScorePoints) {
        if (!starSpawned[p] && score >= p) {
          spawnStar();
          starSpawned[p] = true;
        }
      }
      if (score < doubleShotEndScore) {
        for (const p of doubleShotStarPoints) {
          if (!doubleShotStarSpawned[p] && score > p) {
            spawnDoubleShotStar();
            doubleShotStarSpawned[p] = true;
          }
        }
      }
    }

    // ===== 大ボス専用 15重リング爆発（全面改訂版） =====
    function createFinalBigExplosion(x, y) {
      // 最大半径：従来より 1.5 倍（画面の短い辺の約 0.6）
      const maxRadius = Math.min(canvas.width, canvas.height) * 0.6;
      const maxLife   = 120; // 約2秒

      const baseColors = [
        "#ffffff", "#ffe066", "#ff9933", "#ff5555", "#ff66ff",
        "#66ccff", "#66ff66", "#ffff66", "#ff99cc", "#99ff99",
        "#99ccff", "#ffcc66", "#ff6666", "#ccccff", "#ffffff"
      ];

      const rings = [];
      for (let i = 0; i < 15; i++) {
        rings.push({
          color: baseColors[i % baseColors.length],
          delay: i * 0.03,        // 後ろのリングほど少し遅れて広がる
          width: 3 + i * 0.3      // 外側ほど太く
        });
      }

      finalBigExplosion = {
        x,
        y,
        life: 0,
        maxLife,
        maxRadius,
        rings
      };
    }

    function updateFinalBigExplosion() {
      if (!finalBigExplosion) return;
      finalBigExplosion.life++;
    }

    function drawFinalBigExplosion() {
      if (!finalBigExplosion) return;
      const fw = finalBigExplosion;
      const baseT = fw.life / fw.maxLife; // 0 → 1

      // 先行する「中心の塗りつぶし」円（花火の中身）
      if (baseT > 0) {
        const tLead = Math.min(1, baseT);
        const easeLead = Math.sqrt(tLead);
        const radiusLead = fw.maxRadius * easeLead;

        let fillColor;
        if (baseT < 0.5) {
          // 前半：黄色
          fillColor = "#ffe066";
        } else if (baseT < 0.8) {
          // 中盤：白
          fillColor = "#ffffff";
        } else {
          // 終盤：白と赤白点滅
          const blink = (fw.life % 6) < 3;
          fillColor = blink ? "#ffffff" : "#ffcccc";
        }

        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = fillColor;
        ctx.beginPath();
        ctx.arc(fw.x, fw.y, radiusLead, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // 15重のカラフルなリング
      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      for (let i = 0; i < fw.rings.length; i++) {
        const ring = fw.rings[i];

        const tRaw = (baseT - ring.delay) / (1 - ring.delay);
        if (tRaw <= 0) continue;
        if (tRaw >= 1.1) continue;

        const t = Math.min(1, tRaw);
        const ease = Math.sqrt(t);
        const radius = fw.maxRadius * ease;

        const alpha = (1 - baseT) * 0.9; // 全体として時間と共にフェードアウト
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = ring.color;
        ctx.lineWidth = ring.width;

        ctx.beginPath();
        ctx.arc(fw.x, fw.y, radius, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    }

    function startClearSequence(cx, cy) {
      clearPhase = 1;
      clearFrame = 0;
      explosions.length = 0;
      bullets.length = 0;
      enemyBullets.length = 0;
      enemies.length = 0;

      clearExplosionX = (cx !== undefined) ? cx : canvas.width / 2;
      clearExplosionY = (cy !== undefined) ? cy : canvas.height / 2;

      // 大ボス撃破地点で15重リング爆発
      createFinalBigExplosion(clearExplosionX, clearExplosionY);
      clearFlashTimer = 0; // フラッシュ用タイマー初期化
    }

    // ===== 自機弾 =====
    function spawnPlayerBullet(angleDeg, offsetX = 0) {
      const speed = 8;
      const rad = angleDeg * Math.PI / 180;
      const vx = Math.sin(rad) * speed;
      const vy = -Math.cos(rad) * speed;

      bullets.push({
        x: player.x + player.w / 2 - 3 + offsetX,
        y: player.y,
        w: 6,
        h: 12,
        vx,
        vy
      });
    }

    function firePlayerShots() {
      const baseAngles = powerUpActive ? [-20, 0, 20] : [0];
      if (doubleShotActive) {
        const offset = 8;
        for (const ang of baseAngles) {
          spawnPlayerBullet(ang, -offset);
          spawnPlayerBullet(ang,  offset);
        }
      } else {
        for (const ang of baseAngles) {
          spawnPlayerBullet(ang);
        }
      }
      playSound(shootSound);
    }

    // ===== 敵弾 =====
    function fireEnemyBulletsFromEnemy(enemy) {
      const speed = 5;
      const angle = Math.PI / 6;

      const cx = enemy.x + enemy.w / 2 - 2;
      const cy = enemy.y + enemy.h / 2;

      if (enemy.shotPattern === "double") {
        enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx: 0, vy: speed });

        const vx = Math.sin(angle) * speed * enemy.diagDir;
        const vy = Math.cos(angle) * speed;
        enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx, vy });
      } else {
        const vx = Math.sin(angle) * speed * enemy.diagDir;
        const vy = Math.cos(angle) * speed;
        enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx, vy });
      }
    }

    function fireFinalBossBullets(boss) {
      const speed = 6*1.5;
      const angle = Math.PI / 6;

        // 大ボス：中央下寄りから
      const cx = boss.x + boss.w * 0.5;
      const cy = boss.y + boss.h * 0.78;

      enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx: 0, vy: speed });
      enemyBullets.push({
        x: cx, y: cy, w: 4, h: 10,
        vx: -Math.sin(angle) * speed,
        vy:  Math.cos(angle) * speed
      });
      enemyBullets.push({
        x: cx, y: cy, w: 4, h: 10,
        vx:  Math.sin(angle) * speed,
        vy:  Math.cos(angle) * speed
      });
    }

    // ===== 更新 =====
    function updatePlayer() {
      if (keys["ArrowLeft"]  || keys["KeyA"]) player.x -= player.speed;
      if (keys["ArrowRight"] || keys["KeyD"]) player.x += player.speed;
      if (keys["ArrowUp"]    || keys["KeyW"]) player.y -= player.speed;
      if (keys["ArrowDown"]  || keys["KeyS"]) player.y += player.speed;

      const pad = readGamepad();
      if (pad) {
        const dead = 0.25;
        if (Math.abs(pad.lx) > dead) player.x += pad.lx * player.speed;
        if (Math.abs(pad.ly) > dead) player.y += pad.ly * player.speed;
        if (pad.dpadLeft)  player.x -= player.speed;
        if (pad.dpadRight) player.x += player.speed;
        if (pad.dpadUp)    player.y -= player.speed;
        if (pad.dpadDown)  player.y += player.speed;
      }

      player.x = Math.max(0, Math.min(canvas.width  - player.w, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));

      if (player.fireCooldown > 0) player.fireCooldown--;

      const wantShootKeyboard = keys["Space"] || keys["KeyJ"];
      const wantShootPad = pad && pad.shoot;

      if ((wantShootKeyboard || wantShootPad) && player.fireCooldown === 0) {
        firePlayerShots();
        player.fireCooldown = 8;
      }
      if (powerUpActive) {
        powerUpTimer--;
        if (powerUpTimer <= 0) powerUpActive = false;
      }

      if (doubleShotActive && score >= doubleShotEndScore) {
        doubleShotActive = false;
      }
    }

    function updateBullets() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.y + b.h < 0 || b.y > canvas.height ||
            b.x + b.w < 0 || b.x > canvas.width) {
          bullets.splice(i, 1);
        }
      }
    }

    function updateEnemyBullets() {
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.x += b.vx;
        b.y += b.vy;

        if (b.y > canvas.height || b.x + b.w < 0 || b.x > canvas.width) {
          enemyBullets.splice(i, 1);
          continue;
        }
        if (rectHit({x: player.x, y: player.y, w: player.w, h: player.h}, b)) {
          gameOver = true;
          playSound(playerExplodeSound);
          createExplosion(player.x + player.w/2, player.y + player.h/2, false);
          enemyBullets.splice(i, 1);
        }
      }
    }

    function updateEnemies() {
      if (!finalMode) {
        enemySpawnTimer--;
        if (enemySpawnTimer <= 0) {
          spawnEnemy();
          enemySpawnTimer = 40;
        }

        // ①軌跡：直進通常敵（spawnEnemyで生成される敵）は全て軌跡を描くため、個別スポーンは不要

        // ③頑丈な敵：score>500 で稼働
        if (score > 500) {
          hardTwinSpawnTimer--;
          if (hardTwinSpawnTimer <= 0) {
            spawnHardTwin();
            hardTwinSpawnTimer = randInt(60 * 7, 60 * 12);
          }
        }

        // ②ジグザグ敵：score>900 で稼働
        if (score > 900) {
          zigzagSpawnTimer--;
          if (zigzagSpawnTimer <= 0) {
            spawnZigzagEnemy();
            zigzagSpawnTimer = randInt(60 * 3, 60 * 5);
          }
        }

      } else {
        if (!finalBossSpawned) {
          if (finalDelayFrames > 0) {
            finalDelayFrames--;
          } else {
            spawnFinalBoss();
            finalBossSpawned = true;
          }
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        // 追加敵の個別挙動
        if (e.type === "trail_enemy") {
          e.y += e.speed;

          // 軌跡（当たり判定なし、4秒保持）
          e.trail.push({ x: e.x + e.w/2, y: e.y + e.h/2, life: 240 });
          for (let tt = e.trail.length - 1; tt >= 0; tt--) {
            e.trail[tt].life--;
            if (e.trail[tt].life <= 0) e.trail.splice(tt, 1);
          }

          // 2秒に1回、直進弾
          e.shotTimer--;
          if (e.shotTimer <= 0) {
            enemyBullets.push({ x: e.x + e.w/2 - 2, y: e.y + e.h, w: 4, h: 10, vx: 0, vy: 5 });
            e.shotTimer = 120;
          }

          if (e.y > canvas.height + 50) {
            enemies.splice(i, 1);
            continue;
          }
        } else if (e.type === "zigzag_enemy") {
          e.y += e.speed;

          // ジグザグ（左右に振る）
          e.zigPhase += 0.08;
          e.x = e.baseX + Math.sin(e.zigPhase) * e.zigAmp;

          if (e.x < 0) { e.x = 0; e.baseX = e.x; }
          if (e.x + e.w > canvas.width) { e.x = canvas.width - e.w; e.baseX = e.x; }

          // 3秒に1回、斜め±30度に2発
          e.shotTimer--;
          if (e.shotTimer <= 0) {
            const speed = 5;
            const ang = Math.PI / 6; // 30deg
            const cx = e.x + e.w/2 - 2;
            const cy = e.y + e.h/2;

            enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx: -Math.sin(ang) * speed, vy: Math.cos(ang) * speed });
            enemyBullets.push({ x: cx, y: cy, w: 4, h: 10, vx:  Math.sin(ang) * speed, vy: Math.cos(ang) * speed });
            e.shotTimer = 120;
          }

          if (e.y > canvas.height + 50) {
            enemies.splice(i, 1);
            continue;
          }
        } else if (e.type === "hard_twin") {
          e.y += e.speed;
          if (e.hitFlash > 0) e.hitFlash--;
          if (e.y > canvas.height + 50) {
            enemies.splice(i, 1);
          }
          continue;
        }

        if (e.isMissile) {
          e.y += e.speed;

          // trail (visual only) for straight enemies
          if (Array.isArray(e.trail)) {
            e.trail.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, life: 240 }); // 4 seconds
            for (let t = e.trail.length - 1; t >= 0; t--) {
              e.trail[t].life--;
              if (e.trail[t].life <= 0) e.trail.splice(t, 1);
            }
            // cap length (safety)
            if (e.trail.length > 260) e.trail.splice(0, e.trail.length - 260);
          }

          if (e.y > canvas.height) {
            enemies.splice(i, 1);
            continue;
          }
        } else if (e.isFinalBoss) {
          e.x += e.moveDir * e.speed;
          if (e.x < 0) {
            e.x = 0;
            e.moveDir = 1;
          } else if (e.x + e.w > canvas.width) {
            e.x = canvas.width - e.w;
            e.moveDir = -1;
          }

          e.shotTimer--;
          if (e.shotTimer <= 0) {
            fireFinalBossBullets(e);
            e.shotTimer = 180;
          }
        } else {
          e.y += e.speed;
          // 直進通常敵は全て軌跡（当たり判定なし、4秒保持）
          if (!e.isBoss && !e.isFinalBoss && !e.isMissile && Array.isArray(e.trail)) {
            e.trail.push({ x: e.x + e.w/2, y: e.y + e.h/2, life: 240 });
            for (let t = e.trail.length - 1; t >= 0; t--) {
              e.trail[t].life--;
              if (e.trail[t].life <= 0) e.trail.splice(t, 1);
            }
            // 念のため上限（重くならないように）
            if (e.trail.length > 260) e.trail.splice(0, e.trail.length - 260);
          }

          if (e.y > canvas.height) {
            enemies.splice(i, 1);
            continue;
          }

          // 中ボス：3秒に1回、直進弾を2発
          if (e.isBoss && !e.isFinalBoss) {
            if (typeof e.shotTimer !== "number") e.shotTimer = 180;
            e.shotTimer--;
            if (e.shotTimer <= 0) {
              const speed = 6;
              const y0 = e.y + e.h;
              enemyBullets.push({ x: e.x + e.w * 0.35, y: y0, w: 4, h: 10, vx: 0, vy: speed });
              enemyBullets.push({ x: e.x + e.w * 0.65, y: y0, w: 4, h: 10, vx: 0, vy: speed });
              e.shotTimer = 180;
            }
          }

          if (e.isShooter && !e.isBoss && e.shotsLeft > 0) {
            e.shotTimer--;
            if (e.shotTimer <= 0) {
              fireEnemyBulletsFromEnemy(e);
              e.shotsLeft = 0;
            }
          }
        }

        if (rectHit(player, e)) {
          gameOver = true;
          playSound(playerExplodeSound);
          createExplosion(player.x + player.w/2, player.y + player.h/2, false);
        }
      }
    }

    function updateStarsPower() {
      for (let i = powerStars.length - 1; i >= 0; i--) {
        const s = powerStars[i];
        s.y += s.speed;
        if (s.y > canvas.height) {
          powerStars.splice(i, 1);
          continue;
        }
        const rect = { x: s.x, y: s.y, w: s.size, h: s.size };
        if (rectHit(player, rect)) {
          powerUpActive = true;
          powerUpTimer  = 60 * 8;   
          powerStars.splice(i, 1);
          playSound(starSound);
        }
      }
    }

    function updateDoubleShotStars() {
      if (score >= doubleShotEndScore) {
        doubleShotStars.length = 0;
        return;
      }
      for (let i = doubleShotStars.length - 1; i >= 0; i--) {
        const s = doubleShotStars[i];
        s.y += s.speed;
        if (s.y > canvas.height) {
          doubleShotStars.splice(i, 1);
          continue;
        }
        const rect = { x: s.x, y: s.y, w: s.size, h: s.size };
        if (rectHit(player, rect)) {
          doubleShotActive = true;
          doubleShotStars.splice(i, 1);
          playSound(starSound);
        }
      }
    }

    function handleCollisions() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (rectHit(e, b)) {
            const exX = e.x + e.w / 2;
            const exY = e.y + e.h / 2;

            bullets.splice(j, 1);

            // 最初の敵撃破でBGM開始（解除済みなら）
            startBgmIfReady();

            if (e.isFinalBoss) {
              e.hp--;
              if (e.hp <= 0) {
                playSound(playerExplodeSound);
                startClearSequence(exX, exY); // ここで15重リング演出へ
              }
              break;
            }

            // 頑丈な敵（横2体）：HP=35
            if (e.type === "hard_twin") {
              if (typeof e.hp !== "number") e.hp = 35;
              e.hp--;
              e.hitFlash = 6;
              if (e.hp <= 0) {
                enemies.splice(i, 1);
                score += 40;
                playSound(enemyExplodeSound);
                createExplosion(exX, exY, true);
                handleScoreEvents();
                if (!finalMode) checkBossSpawn();
                tryStartFinalMode();
              }
              break;
            }

            if (e.isBoss) {
              if (typeof e.hp !== "number") e.hp = 20;
              e.hp--;
              if (e.hp <= 0) {
                enemies.splice(i, 1);
                score += 10;
                playSound(playerExplodeSound);
                createExplosion(exX, exY, true);
                handleScoreEvents();
                if (!finalMode) checkBossSpawn();
                tryStartFinalMode();
              }
            } else if (e.isMissile) {
              enemies.splice(i, 1);
              score += 20;
              playSound(enemyExplodeSound);
              createExplosion(exX, exY, false);
              handleScoreEvents();
              if (!finalMode) checkBossSpawn();
              tryStartFinalMode();
            } else {
              enemies.splice(i, 1);
              score += 10;
              playSound(enemyExplodeSound);
              createExplosion(exX, exY, false);
              handleScoreEvents();
              if (!finalMode) checkBossSpawn();
              tryStartFinalMode();
            }
            break;
          }
        }
      }
    }

    function rectHit(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    // ===== 通常の爆発（敵・ミサイル用） =====
    const explosionPatterns = [
      {
        maxLife: 26,
        radiusScale: 1.0,
        rings: [
          { r: 0.35, color: "#ff3300", alpha: 0.9 },
          { r: 0.7,  color: "#ff9900", alpha: 0.7 },
          { r: 1.0,  color: "#ffdd55", alpha: 0.5 }
        ]
      },
      {
        maxLife: 28,
        radiusScale: 1.1,
        rings: [
          { r: 0.25, color: "#ffffcc", alpha: 0.9 },
          { r: 0.55, color: "#ffdd33", alpha: 0.75 },
          { r: 0.8,  color: "#ccff66", alpha: 0.6 },
          { r: 1.0,  color: "#99ff66", alpha: 0.4 }
        ]
      },
      {
        maxLife: 24,
        radiusScale: 0.9,
        rings: [
          { r: 0.3,  color: "#ff4444", alpha: 0.9 },
          { r: 0.6,  color: "#ffee66", alpha: 0.7 },
          { r: 0.9,  color: "#99ff66", alpha: 0.55 },
          { r: 1.15, color: "#66ffee", alpha: 0.35 }
        ]
      },
      {
        maxLife: 30,
        radiusScale: 1.2,
        rings: [
          { r: 0.2,  color: "#ffcc33", alpha: 1.0 },
          { r: 0.5,  color: "#ffff66", alpha: 0.8 },
          { r: 0.85, color: "#ff9933", alpha: 0.6 },
          { r: 1.1,  color: "#99ff66", alpha: 0.4 }
        ]
      }
    ];

    function createExplosion(x, y, big) {
      const patternIndex = (Math.random() * explosionPatterns.length) | 0;
      const pattern = explosionPatterns[patternIndex];

      const baseSmall = 28;
      const baseRadius = big ? baseSmall * 8 : baseSmall;

      explosions.push({
        x,
        y,
        life: 0,
        patternIndex,
        maxRadius: baseRadius * pattern.radiusScale
      });
    }

    function updateExplosions() {
      for (let i = explosions.length - 1; i >= 0; i--) {
        const ex = explosions[i];
        const pattern = explosionPatterns[ex.patternIndex];

        ex.life++;
        const totalLife = pattern.maxLife * 2;
        if (ex.life >= totalLife) {
          explosions.splice(i, 1);
        }
      }
    }

    function drawExplosions() {
      for (const ex of explosions) {
        const pattern = explosionPatterns[ex.patternIndex];
        const totalLife = pattern.maxLife * 2;
        const t = ex.life / totalLife;
        const ease = Math.sqrt(t);
        const alphaBase = 1 - t;

        ctx.save();
        ctx.globalCompositeOperation = "lighter";

        for (const ring of pattern.rings) {
          const radius = ex.maxRadius * ring.r * ease;
          if (radius <= 0) continue;

          ctx.globalAlpha = alphaBase * ring.alpha;
          ctx.fillStyle = ring.color;
          ctx.beginPath();
          ctx.arc(ex.x, ex.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.globalAlpha = alphaBase * 0.9;
        ctx.fillStyle = "#ffffee";
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.maxRadius * 0.15 * (1 - t), 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    // ===== 自機スプライト =====
    function drawPlayerSprite(scale) {
      const rows = playerMap.length;
      const cols = playerMap[0].length;
      const cell = 2 * scale;

      const totalW = cols * cell;
      const totalH = rows * cell;
      const offsetX = -totalW / 2;
      const offsetY = -totalH / 2;

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const v = playerMap[y][x];
          if (v === 0) continue;

          let col;
          switch (v) {
            case 1: col = "#1fd13b"; break;
            case 2: col = "#0a7f1f"; break;
            case 3: col = "#ff3333"; break;
            case 4: col = "#8fd8ff"; break;
            case 5: col = "#555555"; break;
            case 6: col = "#c07020"; break;
            default: continue;
          }

          ctx.fillStyle = col;
          ctx.fillRect(
            offsetX + x * cell,
            offsetY + y * cell,
            cell,
            cell
          );
        }
      }
    }

    // ===== タイトル画面 =====
    function drawTitleScreen() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 星
      ctx.fillStyle = "#fff";
      for (const s of stars) {
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }

      ctx.fillStyle = "#00ffff";
      ctx.textAlign = "center";
      ctx.font = "40px monospace";
      ctx.fillText("THE SHOOTINGⅡ", canvas.width / 2, 160);

      ctx.font = "14px monospace";
      ctx.fillStyle = "#88ff88";
      ctx.fillText("1 PLAYER   XBOX / KEYBOARD", canvas.width / 2, 200);

      const blinkOn = Math.floor(frameCount / 30) % 2 === 0;
      if (blinkOn) {
        ctx.font = "20px monospace";
        ctx.fillStyle = "#ffffff";
        ctx.fillText("PUSH ANY BUTTON", canvas.width / 2, 320);
      }

      ctx.font = "12px monospace";
      ctx.fillStyle = "#cccccc";
      ctx.fillText("", canvas.width / 2, 350);

      ctx.save();
      ctx.translate(canvas.width / 2, 480);
      drawPlayerSprite(1.2);
      ctx.restore();

      ctx.textAlign = "left";
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
      drawPlayerSprite(1);
      ctx.restore();
    }

    function drawBullets() {
      ctx.fillStyle = "#ff0";
      for (const b of bullets) {
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }
    }

    function drawEnemyBullets() {
      ctx.fillStyle = "#ff5555";
      for (const b of enemyBullets) {
        ctx.fillRect(b.x, b.y, b.w, b.h);
      }
    }

    function drawEnemyTrails() {
      ctx.save();
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.globalCompositeOperation = "lighter";

      for (const e of enemies) {
        if (!Array.isArray(e.trail) || e.trail.length < 2) continue;
        if (!e.trail || e.trail.length < 2) continue;

        ctx.strokeStyle = e.trailColor || "rgba(255,255,0,0.8)";
        ctx.beginPath();

        for (let i = 0; i < e.trail.length; i++) {
          const p = e.trail[i];
          const a = (p.life / 240) * 0.9;
          ctx.globalAlpha = a;
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      ctx.restore();
    }


    function updateBackgroundScroll() {
      for (const bg of backgroundScrolls) {
        if (!bg.triggered && score >= bg.triggerScore) {
          bg.triggered = true;
          if (bg.loaded) {
            startBackgroundScroll(bg);
          } else {
            bg.pending = true;
          }
        }

        if (!bg.active) continue;
        bg.y += backgroundScrollSpeed;
        if (bg.y >= canvas.height) {
          bg.active = false;
        }
      }
    }

    function drawBackgroundScroll() {
      for (const bg of backgroundScrolls) {
        if (!bg.active || !bg.loaded) continue;

        // back2特例：framesがあるときは交互に描く
        const img = (bg.frames && bg.frames.length)
          ? bg.frames[(Math.floor(frameCount / bg.frameInterval) % bg.frames.length)]
          : bg.image;

        ctx.drawImage(img, 0, bg.y, canvas.width, canvas.height);
      }
    }


    function drawEnemies() {
      for (const e of enemies) {
        ctx.save();
        ctx.translate(e.x, e.y);

        if (e.isFinalBoss) {
          if (finalBossImageLoaded) {
            ctx.drawImage(finalBossImage, 0, 0, e.w, e.h);
          } else {
            ctx.fillStyle = "#ff9933";
            ctx.fillRect(0, 0, e.w, e.h);
          }

        } else if (e.isBoss && !e.isFinalBoss) {
          const rows = midBossMap.length;
          const cols = midBossMap[0].length;
          const cellW = e.w / cols;
          const cellH = e.h / rows;

          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              const v = midBossMap[y][x];
              if (v === 0) continue;

              let col;
              if (v === 1)      col = "#3a9ad9"; // 暗い水色
              else if (v === 2) col = "#73c7ff"; // 水色
              else if (v === 3) col = "#0c2f73"; // 紺色
              else if (v === 4) col = "#9c9c9c"; // グレー
              else if (v === 5) col = "#555555"; // 濃いグレー
              else if (v === 6) col = "#d43131"; // 赤
              else if (v === 7) col = "#ff8c2a"; // オレンジ
              else continue;

              ctx.fillStyle = col;
              ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
            }
          }

        } else if (e.isMissile) {
          const rows = missileMap.length;
          const cols = missileMap[0].length;
          const cellW = e.w / cols;
          const cellH = e.h / rows;

          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              const v = missileMap[rows - 1 - y][x]; // 下から参照（上下反転）
              if (v === 0) continue;
              ctx.fillStyle = (v === 1) ? "#ffffff" : "#ff3333";
              ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
            }
          }

          const flicker = (frameCount % 6) - 3;
          ctx.fillStyle = "rgba(255,180,0,0.7)";
          ctx.beginPath();
          ctx.arc(e.w / 2, -6 + flicker * 0.5, 5, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "rgba(200,200,200,0.5)";
          ctx.beginPath();
          ctx.arc(e.w / 2 - 4, -14 + flicker * 0.3, 4, 0, Math.PI * 2);
          ctx.arc(e.w / 2 + 3, -17 + flicker * 0.4, 3, 0, Math.PI * 2);
          ctx.fill();

        } else if (e.type === "hard_twin") {
          const rows = hardTwinMap.length;
          const cols = hardTwinMap[0].length;
          const cellW = e.w / cols;
          const cellH = e.h / rows;
          const flash = (e.hitFlash > 0);

          for (let yy = 0; yy < rows; yy++) {
            for (let xx = 0; xx < cols; xx++) {
              const v = hardTwinMap[yy][xx];
              if (v === 0) continue;
              ctx.fillStyle = "#9aa0a6";
              ctx.fillRect(xx * cellW, yy * cellH, cellW, cellH);
            }
          }

        } else {
          ctx.translate(e.w / 2, e.h / 2);
          ctx.fillStyle = e.color ? e.color : (e.isShooter ? "#ff66aa" : "#f33");
          ctx.fillRect(-4, -12, 8, 24);
          ctx.fillRect(-14, -3, 28, 6);
          ctx.fillRect(-5, 7, 10, 4);

          ctx.fillStyle = "#faa";
          ctx.fillRect(-3, -9, 6, 5);
        }

        ctx.restore();
      }
    }

    function drawUI() {
      ctx.fillStyle = "#fff";
      ctx.font = "18px sans-serif";
      ctx.fillText("SCORE: " + score, 10, 24);
    }

    function drawGameOver() {
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      ctx.font = "32px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 10);
      ctx.font = "12px sans-serif";
      ctx.fillText("Rキーorゲームパッドの各ボタンでリスタート", canvas.width / 2, canvas.height / 2 + 30);
      ctx.textAlign = "left";
    }

    function drawStarsPower() {
      for (const s of powerStars) {
        const cx = s.x + s.size / 2;
        const cy = s.y + s.size / 2;
        const r  = s.size / 2;
        const blinkOn = Math.floor(frameCount / 10) % 2 === 0;
        ctx.fillStyle = blinkOn ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.35)";
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const ang  = (Math.PI * 2 / 5) * i - Math.PI / 2;
          const ang2 = ang + Math.PI / 5;
          const r1 = r;
          const r2 = r * 0.4;
          if (i === 0) ctx.moveTo(cx + Math.cos(ang) * r1, cy + Math.sin(ang) * r1);
          ctx.lineTo(cx + Math.cos(ang) * r1,  cy + Math.sin(ang) * r1);
          ctx.lineTo(cx + Math.cos(ang2) * r2, cy + Math.sin(ang2) * r2);
        }
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawDoubleShotStars() {
      for (const s of doubleShotStars) {
        const cx = s.x + s.size / 2;
        const cy = s.y + s.size / 2;
        const r  = s.size / 2;

        const blinkOn = Math.floor(frameCount / 8) % 2 === 0;
        ctx.fillStyle = blinkOn ? "rgba(255,255,255,0.95)" : "rgba(255,255,255,0.35)";

        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const ang  = (Math.PI * 2 / 5) * i - Math.PI / 2;
          const ang2 = ang + Math.PI / 5;
          const r1 = r;
          const r2 = r * 0.4;
          if (i === 0) ctx.moveTo(cx + Math.cos(ang) * r1, cy + Math.sin(ang) * r1);
          ctx.lineTo(cx + Math.cos(ang) * r1,  cy + Math.sin(ang) * r1);
          ctx.lineTo(cx + Math.cos(ang2) * r2, cy + Math.sin(ang2) * r2);
        }
        ctx.closePath();
        ctx.fill();
      }
    }
    // ===== クリア演出 =====
    function drawClearScreen() {
      if (endingImageLoaded) {
        ctx.drawImage(endingImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.font = "26px monospace";
        ctx.fillText("CONGRATULATION!", canvas.width / 2, canvas.height / 2);
        ctx.font = "16px monospace";
        ctx.fillText("PUSH BUTTON TO TITLE", canvas.width / 2, canvas.height / 2 + 40);
        ctx.textAlign = "left";
      }
    }

    function updateClearExplosionPhase() {
      clearFrame++;
      updateFinalBigExplosion();

      // 爆発が寿命を迎えたら白フラッシュ開始
      if (finalBigExplosion && finalBigExplosion.life >= finalBigExplosion.maxLife && clearFlashTimer === 0) {
        clearFlashTimer = 15; // フレーム数ぶん白フラッシュ
      }

      // フラッシュが終わったら次フェーズ（自機クルーズ）へ
      if (clearFlashTimer > 0) {
        clearFlashTimer--;
        if (clearFlashTimer === 0) {
          clearPhase = 2;
          clearFrame = 0;
          finalBigExplosion = null;
        }
      }
    }

function drawClearExplosionPhase() {
  // 背景黒
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // 花火爆発描画
  drawFinalBigExplosion();

  // 爆発終了後の白フラッシュ
  if (clearFlashTimer > 0) {
    const alpha = clearFlashTimer / 15;
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // 最後に自機を必ず描く（常に表示）
  drawPlayer();
}

    function updateCruisePhase() {
      clearFrame++;

      for (const s of stars) {
        s.y += 1.5;
        if (s.y > canvas.height) s.y -= canvas.height;
      }

      player.y -= 0.8;
      const limitY = canvas.height * 0.3;
      if (player.y < limitY) player.y = limitY;

      if (clearFrame >= 60 * 5) {
        clearPhase = 3;
        clearFrame = 0;
        gameCleared = true;
      }
    }

    function drawCruisePhase() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#ffffff";
      for (const s of stars) {
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }

      drawPlayer();
    }

    // ===== スコア関連フラグリセット =====
    function resetScoreFlags() {
      for (const k in missileSpawned) delete missileSpawned[k];
      for (const k in starSpawned) delete starSpawned[k];
      for (const k in doubleShotStarSpawned) delete doubleShotStarSpawned[k];
    }

    function startGame() {
      bullets.length = 0;
      enemies.length = 0;
      enemyBullets.length = 0;
      explosions.length = 0;
      powerStars.length = 0;
      doubleShotStars.length = 0;
      resetScoreFlags();
      powerUpActive = false;
      powerUpTimer  = 0;
      doubleShotActive = false;

      score = 0;
      nextBossScore = 300;
      enemySpawnTimer = 30;
      trailSpawnTimer = randInt(60 * 5, 60 * 10);
      hardTwinSpawnTimer = randInt(60 * 6, 60 * 12);
      zigzagSpawnTimer = randInt(60 * 6, 60 * 12);
      player.x = canvas.width / 2 - 15;
      player.y = canvas.height - 80;
      player.fireCooldown = 0;
      gameOver = false;
      gameStarted = true;
      gameCleared = false;

      finalMode = false;
      finalDelayFrames = 0;
      finalBossSpawned = false;

      clearPhase = 0;
      clearFrame = 0;
      finalBigExplosion = null;
      clearFlashTimer = 0;

      resetBackgroundScrolls();
    }

    function backToTitle() {
      bullets.length = 0;
      enemies.length = 0;
      enemyBullets.length = 0;
      explosions.length = 0;
      powerStars.length = 0;
      resetScoreFlags();
      doubleShotActive = false;

      score = 0;
      nextBossScore = 300;
      enemySpawnTimer = 30;
      trailSpawnTimer = randInt(60 * 5, 60 * 10);
      hardTwinSpawnTimer = randInt(60 * 6, 60 * 12);
      zigzagSpawnTimer = randInt(60 * 6, 60 * 12);
      player.fireCooldown = 0;

      finalMode = false;
      finalDelayFrames = 0;
      finalBossSpawned = false;

      clearPhase = 0;
      clearFrame = 0;
      finalBigExplosion = null;
      clearFlashTimer = 0;

      resetBackgroundScrolls();

      gameStarted = false;
      gameOver = false;
      gameCleared = false;
    }

    // ===== メインループ =====
    enemySpawnTimer = 30;

    function loop() {
      frameCount++;


  try {
    // ===== ここから今の loop の中身を全部入れる（既存処理そのまま） =====
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    const pad0 = (activeGamepadIndex != null) ? pads[activeGamepadIndex] : pads[0];

    const restartByGamepad = isGamepadRestartJustPressed(pad0);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updateBackgroundScroll();
    drawBackgroundScroll();

    if (clearPhase === 1) {
      updateClearExplosionPhase();
      drawClearExplosionPhase();
    } else if (clearPhase === 2) {
      updateCruisePhase();
      drawCruisePhase();
    } else if (clearPhase === 3) {
      drawClearScreen();
    } else if (!gameStarted) {
      drawTitleScreen();
      if (pad0 && pad0.buttons) {
        const anyPressed = pad0.buttons.some(b => b.pressed);
        if (anyPressed) {
          unlockBgm();
          startGame();
        }
      }
    } else {
      if (!gameCleared && gameOver && restartByGamepad) {
        startGame();
      }

      if (!gameOver) {
        updatePlayer();
        updateBullets();
        updateEnemyBullets();
        updateEnemies();
        updateStarsPower();
        updateDoubleShotStars();
        handleCollisions();
        updateExplosions();

        drawPlayer();
        drawBullets();
        drawEnemyBullets();
        drawEnemyTrails();
        drawEnemies();
        drawExplosions();
        drawStarsPower();
        drawDoubleShotStars();
        drawUI();
      } else {
        updateExplosions();
        drawPlayer();
        drawBullets();
        drawEnemyBullets();
        drawEnemyTrails();
        drawEnemies();
        drawExplosions();
        drawUI();
        drawGameOver();
      }
    }
    // ===== ここまで =====

    lastError = null;
  } catch (e) {
    lastError = e;

  }

  requestAnimationFrame(loop);
}
    loop();
  </script>
</body>
</html>
